### Детали реализации

Реализуйте шаблон `Optional<T>`, упрощенный аналог `std::optional<T>`. В полях шаблона сохраните память (массив char или `std::aligned_storage_t`) достаточного размера (память должна располагаться на стеке!), а также булевское поле, в котором будет храниться информация о том, жив ли объект. Шаблонный класс должен поддерживать следующие методы:

- **Конструктор по умолчанию**: Создает `Optional` с "мертвым" объектом.
- **Конструктор копирования**: Создает копию, если копируемый объект жив, и пустой `Optional` иначе.
- **Конструктор перемещения**: Если перемещаемый `Optional` пуст, то создается пустой объект. Иначе перемещаем объект из другого `Optional`. При этом старый `Optional` по-прежнему остается живым!
- **Неявный конструктор от `const T&` и `T&&`**: Создает `Optional`, созданный с помощью переданного объекта (копированием или перемещением).
- **Деструктор**: Вызывает деструктор объекта, если тот жив, и ничего не делает, если мертв.
- **Копирующее и перемещающее присваивание**: Если копируемый (перемещаемый) объект мертв, то и свой объект становится мертвым. Иначе своему объекту нужно соответствующим образом присвоить другой (и если был мертв, то оживить).
- **Присваивание от `const T&` и `T&&`**: Аналогично предыдущему (только копируемый объект априори жив).
- **`bool HasValue()`**: Возвращает жив объект, либо нет.
- **Явное приведение к `bool`**: Аналогично предыдущему.
- **`Value()`**: Возвращает ссылку на объект. Если объект мертв, то бросается исключение `BadOptionalAccess` (которое тоже надо реализовать). Поддержать константную и неконстантную версии.
- **Константный и неконстантный `operator*`**: Аналогичен `Value`, но не осуществляет проверок.
- **`T& Emplace(args...)`**: Принимает аргументы конструктора, с которыми нужно пересоздать объект (если он был жив, то вызвать деструктор и создать заново).
- **`void Reset()`**: Уничтожить объект, если тот был жив.
