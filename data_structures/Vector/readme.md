### Детали реализации

От вас требуется реализовать шаблонный класс `Vector` с единственным шаблонным параметром - типом хранящихся элементов. При реализации можно (и даже нужно) пользоваться обобщенными алгоритмами из STL (`std::copy`, `std::fill` и т.п.), но нельзя использовать стандартные контейнеры. Будет проверяться корректность мультипликативной схемы расширения массива с коэффициентом 2. В базовой версии ручное управление временем жизни объектов не требуется (см. доп. задание). Класс должен поддерживать следующий функционал:

- **Конструктор по умолчанию**: Создает пустой массив.
- **Явный конструктор от числа**: Создает массив заданного размера, заполненный объектами, сконструированными по умолчанию.
- **Конструктор, принимающий size и value**: Создает массив длины size, заполненный элементами со значением value.
- **Шаблонный конструктор, принимающий пару итераторов**: Создает копию переданного диапазона.
- **Конструктор от `std::initializer_list`**.
- **Правило "пяти"**.
- Методы `Size`, `Capacity`, `Empty`.
- Константный и неконстантный оператор доступа по индексу `[]`. Неконстантный должен позволять изменять полученный элемент.
- Константный и неконстантный метод доступа по индексу `At`. При выходе за границы массива должен бросать исключение `std::out_of_range`.
- Методы `Front()` и `Back()`, доступ к первому и последнему элементам (тоже по две версии).
- Метод `Data()`, возвращает указатель на начало массива.
- Метод `Swap(other)`, обменивает содержимое с другим массивом `other`.
- Метод `Resize(new_size)`, изменяет размер на `new_size`. Если вместимость не позволяет хранить столько элементов, то выделяется новый буфер с вместимостью `new_size`. Недостающие элементы конструируются по умолчанию.
- Метод `Resize(new_size, value)`, то же, что и `Resize(new_size)`, но в случае `new_size > size` заполняет недостающие элементы значением `value`.
- Метод `Reserve(new_cap)`, изменяет вместимость на `max(new_cap, текущая вместимость)`. Размер при этом не изменяется.
- Метод `ShrinkToFit()`, уменьшает `capacity` до `size`.
- Метод `Clear()`, устанавливает размер в 0, очищения выделенной памяти при этом НЕ происходит.
- Методы `PushBack(const T&)` и `PushBack(T&&)`, добавляет новый элемент в конец массива.
- Метод `PopBack()`, удаляет последний элемент.
- Операции сравнения (`<`, `>`, `<=`, `>=`, `==`, `!=`), задающие лексикографический порядок.

Также реализуйте поддержку итераторов и методы для работы с ними: `begin()`, `end()`, `cbegin()`, `cend()`, `rbegin()`, `rend()`, `crbegin()`, `crend()`. `begin()-end()`, `rbegin()-rend()` должны иметь две версии, возвращающие константные и неконстантные итераторы.

Внутри класса `Vector` определите типы-члены `ValueType`, `Pointer`, `ConstPointer`, `Reference`, `ConstReference`, `SizeType`, `Iterator`, `ConstIterator`.

### Гарантии безопасности

Спроектируйте класс так, чтобы при возникновении исключений (нехватка памяти, ошибка при копировании объектов и т.п.) методы удовлетворяли строгой гарантии безопасности. То есть все методы должны работать атомарно: либо работать без сбоев, либо не изменять исходного состояния вектора. Исключение: копирующее присваивание может давать лишь базовую гарантию безопасности.

При решении можно предполагать, что конструкторы перемещения, перемещающие присваивания и деструкторы объектов никогда не бросают исключений!
